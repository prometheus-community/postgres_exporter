#
# This is a user-defined metrics mapping for postgres_exporter.
#
# It supplements the built-in set of metrics that postgres_exporter scrapes
# with additional user-defined queries.
#
# Each top-level entry in the map defines a set of metrics whose values and
# optionally labels (dimensions) are provided by a single SQL query. Each
# result column of the query either supplies a value for a metric or adds a
# Prometheus label (dimension) to qualify the metric.
#
# The emitted metrics are named {group_name}_{query_result_column_name}.
#
# Each entry in the top-level map must have a map value with keys:
#
#   query      SQL query string that is executed verbatim on the server
#              to capture metrics values and any qualifying LABEL values
#              specified by the 'metrics' key. Value required.
#
#              Each result column maps to a Prometheus metric or a label
#              depending on the configuration in the 'metrics' map.
#
#   master     Boolean flag controlling whether this query is run only
#              on the default database postgres_exporter connects to.
#              Only has an effect if auto-discover databases is on. Defaults to
#              false.
#
#   metrics    Map of query result column names to metric type and description.
#              Optional. If no entry is present for a given result column name
#              the metric type is assumed to be COUNTER and no description
#              for the metric is supplied to the scraper.
#
# Each of the 'metrics' entries has a key that exactly matches a result column
# name. Entries that don't match any column are ignored. Use `AS` to alias
# column names explicitly in your queries to ensure they are predictable. The
# value is a map with keys:
#
#   usage        String 'COUNTER', 'GAUGE', 'DISCARD', 'HISTOGRAM', 'DURATION',
#                'MAPPEDMETRIC' or 'LABEL'. Defines how values in this column
#                are mapped to the metrics output.
#
#   description  Short text description of the metric for display in tools that
#                consume Prometheus metrics.
#
# Usage types:
#
#   GAUGE        Prometheus metric type. A numeric value that may increase or
#                decrease between scrapes.
#
#                The postgres type must be an integer or floating point type,
#                timestamp (which will be converted to floating point unix
#                epoch seconds with fractional milliseconds), or boolean
#                (converted to 0 or 1).
#
#                String values will be parsed as floating point numbers - so
#                they should be avoided.
#
#                Time intervals should be exposed as fractional epoch seconds
#                using `extract(epoch from some_interval_value)`. This will
#                preserve fractional milliseconds. pg_exporter will NOT handle
#                ISO8601 interval string representations.
#
#   COUNTER      Prometheus metric type. A monotonically increasing value.
#                Decreases are treated as counter resets.
#
#                Same data type handling as GAUGE.
#
#   DURATION     Converter that produces a GAUGE typed metric from a time
#                interval string representation compatible with golang's
#                time.ParseDuration function. Little-used.
#
#   HISTOGRAM    A Prometheus histogram metric per Prometheus documentation.
#
#   LABEL        Instead of using the value as a metric, use this column as
#                the value of a Prometheus label. All other metrics collected
#                for this query will have this label. Add multiple labels for
#                multiple dimensions.
#
#                Unlike metrics values, labels may be strings - you may use the
#                "text" or "varchar" database types.
#
#   DISCARD      This column should be ignored.
#
#   (default)    If no usage for a metric is specified, it is assumed to be
#                a GAUGE.
#
# Metrics queries return one or more columns. Each column is bound to a result
# metric or label depending on the configuration in the
# metrics['column_name'].usage mapping for the column. Use `AS` to alias column
# names in the query to predictably match the names in the metrics map and avoid
# problems with "?column?" names, duplicate column names, etc.
#
# Metrics queries may return zero or more rows. If zero rows are returned, no
# values will be scraped for the set of metrics. If one or more rows are
# returned, each column is bound to a metric value or label dimension as
# specified by the 'metrics' key. Since Prometheus expects each metric to be
# unique in a given scrape, queries that return multiple rows should bind at
# least one result column to a LABEL that makes each row a distinct metrics
# dimension. For example, per-table metrics should bind the table's qualified
# name to a LABEL.
#
# If auto-discover-databases is enabled, the exporter will run this query once
# for each discovered database unless overridden by a 'master: true' setting on
# the metric. The 'master' setting restricts the metric to run *only* on the
# default database that postgres_exporter connects to with the user-supplied
# connection string. Metrics queries not constrained to the master connection
# should include a LABEL bound to the result of the SQL current_database()
# function to ensure that the metrics are unique within a given scrape.
#
#


pg_replication:
  query: "SELECT CASE WHEN NOT pg_is_in_recovery() THEN 0 ELSE GREATEST (0, EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp()))) END AS lag"
  #
  # WARNING: "master" means the default database postgres_fdw connects to, NOT
  # the replication master in a primary/replica deployment!
  #
  # Use "master: true" for queries that only need to run once for the whole
  # server, rather than for each database.
  #
  master: true
  metrics:
    - lag:
        usage: "GAUGE"
        description: "Replication lag behind master in seconds"

pg_postmaster:
  query: "SELECT pg_postmaster_start_time as start_time_seconds from pg_postmaster_start_time()"
  master: true
  metrics:
    - start_time_seconds:
        usage: "GAUGE"
        description: "Time at which postmaster started"

pg_stat_user_tables:
  # Note that this query exposes current_database() as a column named
  # 'datname'. It does not have 'master: true' set, so it'll run for each
  # database discovered in pg_database (after applying include/exclude lists).
  query: |
   SELECT
     current_database() datname,
     schemaname,
     relname,
     seq_scan,
     seq_tup_read,
     idx_scan,
     idx_tup_fetch,
     n_tup_ins,
     n_tup_upd,
     n_tup_del,
     n_tup_hot_upd,
     n_live_tup,
     n_dead_tup,
     n_mod_since_analyze,
     COALESCE(last_vacuum, '1970-01-01Z') as last_vacuum,
     COALESCE(last_autovacuum, '1970-01-01Z') as last_autovacuum,
     COALESCE(last_analyze, '1970-01-01Z') as last_analyze,
     COALESCE(last_autoanalyze, '1970-01-01Z') as last_autoanalyze,
     vacuum_count,
     autovacuum_count,
     analyze_count,
     autoanalyze_count
   FROM
     pg_stat_user_tables
  metrics:
    # The 'datname' column is mapped to a metric dimension, so each database
    # produces a unique metric even if they have tables with identical names.
    - datname:
        usage: "LABEL"
        description: "Name of current database"
    # This metric is multi-dimensional since it's also qualified by database
    # schema and table name.
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - seq_scan:
        usage: "COUNTER"
        description: "Number of sequential scans initiated on this table"
    - seq_tup_read:
        usage: "COUNTER"
        description: "Number of live rows fetched by sequential scans"
    - idx_scan:
        usage: "COUNTER"
        description: "Number of index scans initiated on this table"
    - idx_tup_fetch:
        usage: "COUNTER"
        description: "Number of live rows fetched by index scans"
    - n_tup_ins:
        usage: "COUNTER"
        description: "Number of rows inserted"
    - n_tup_upd:
        usage: "COUNTER"
        description: "Number of rows updated"
    - n_tup_del:
        usage: "COUNTER"
        description: "Number of rows deleted"
    - n_tup_hot_upd:
        usage: "COUNTER"
        description: "Number of rows HOT updated (i.e., with no separate index update required)"
    - n_live_tup:
        usage: "GAUGE"
        description: "Estimated number of live rows"
    - n_dead_tup:
        usage: "GAUGE"
        description: "Estimated number of dead rows"
    - n_mod_since_analyze:
        usage: "GAUGE"
        description: "Estimated number of rows changed since last analyze"
    - last_vacuum:
        usage: "GAUGE"
        description: "Last time at which this table was manually vacuumed (not counting VACUUM FULL)"
    - last_autovacuum:
        usage: "GAUGE"
        description: "Last time at which this table was vacuumed by the autovacuum daemon"
    - last_analyze:
        usage: "GAUGE"
        description: "Last time at which this table was manually analyzed"
    - last_autoanalyze:
        usage: "GAUGE"
        description: "Last time at which this table was analyzed by the autovacuum daemon"
    - vacuum_count:
        usage: "COUNTER"
        description: "Number of times this table has been manually vacuumed (not counting VACUUM FULL)"
    - autovacuum_count:
        usage: "COUNTER"
        description: "Number of times this table has been vacuumed by the autovacuum daemon"
    - analyze_count:
        usage: "COUNTER"
        description: "Number of times this table has been manually analyzed"
    - autoanalyze_count:
        usage: "COUNTER"
        description: "Number of times this table has been analyzed by the autovacuum daemon"

pg_statio_user_tables:
  query: "SELECT current_database() datname, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read, tidx_blks_hit FROM pg_statio_user_tables"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of current database"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - heap_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table"
    - heap_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table"
    - idx_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from all indexes on this table"
    - idx_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in all indexes on this table"
    - toast_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table's TOAST table (if any)"
    - toast_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table's TOAST table (if any)"
    - tidx_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table's TOAST table indexes (if any)"
    - tidx_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table's TOAST table indexes (if any)"

pg_database:
  query: "SELECT pg_database.datname, pg_database_size(pg_database.datname) as size_bytes FROM pg_database"
  master: true
  cache_seconds: 30
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of the database"
    - size_bytes:
        usage: "GAUGE"
        description: "Disk space used by the database"

pg_stat_statements:
  query: "SELECT t2.rolname, t3.datname, queryid, calls, total_time / 1000 as total_time_seconds, min_time / 1000 as min_time_seconds, max_time / 1000 as max_time_seconds, mean_time / 1000 as mean_time_seconds, stddev_time / 1000 as stddev_time_seconds, rows, shared_blks_hit, shared_blks_read, shared_blks_dirtied, shared_blks_written, local_blks_hit, local_blks_read, local_blks_dirtied, local_blks_written, temp_blks_read, temp_blks_written, blk_read_time / 1000 as blk_read_time_seconds, blk_write_time / 1000 as blk_write_time_seconds FROM pg_stat_statements t1 JOIN pg_roles t2 ON (t1.userid=t2.oid) JOIN pg_database t3 ON (t1.dbid=t3.oid) WHERE t2.rolname != 'rdsadmin'"
  master: true
  metrics:
    - rolname:
        usage: "LABEL"
        description: "Name of user"
    - datname:
        usage: "LABEL"
        description: "Name of database"
    - queryid:
        usage: "LABEL"
        description: "Query ID"
    - calls:
        usage: "COUNTER"
        description: "Number of times executed"
    - total_time_seconds:
        usage: "COUNTER"
        description: "Total time spent in the statement, in milliseconds"
    - min_time_seconds:
        usage: "GAUGE"
        description: "Minimum time spent in the statement, in milliseconds"
    - max_time_seconds:
        usage: "GAUGE"
        description: "Maximum time spent in the statement, in milliseconds"
    - mean_time_seconds:
        usage: "GAUGE"
        description: "Mean time spent in the statement, in milliseconds"
    - stddev_time_seconds:
        usage: "GAUGE"
        description: "Population standard deviation of time spent in the statement, in milliseconds"
    - rows:
        usage: "COUNTER"
        description: "Total number of rows retrieved or affected by the statement"
    - shared_blks_hit:
        usage: "COUNTER"
        description: "Total number of shared block cache hits by the statement"
    - shared_blks_read:
        usage: "COUNTER"
        description: "Total number of shared blocks read by the statement"
    - shared_blks_dirtied:
        usage: "COUNTER"
        description: "Total number of shared blocks dirtied by the statement"
    - shared_blks_written:
        usage: "COUNTER"
        description: "Total number of shared blocks written by the statement"
    - local_blks_hit:
        usage: "COUNTER"
        description: "Total number of local block cache hits by the statement"
    - local_blks_read:
        usage: "COUNTER"
        description: "Total number of local blocks read by the statement"
    - local_blks_dirtied:
        usage: "COUNTER"
        description: "Total number of local blocks dirtied by the statement"
    - local_blks_written:
        usage: "COUNTER"
        description: "Total number of local blocks written by the statement"
    - temp_blks_read:
        usage: "COUNTER"
        description: "Total number of temp blocks read by the statement"
    - temp_blks_written:
        usage: "COUNTER"
        description: "Total number of temp blocks written by the statement"
    - blk_read_time_seconds:
        usage: "COUNTER"
        description: "Total time the statement spent reading blocks, in milliseconds (if track_io_timing is enabled, otherwise zero)"
    - blk_write_time_seconds:
        usage: "COUNTER"
        description: "Total time the statement spent writing blocks, in milliseconds (if track_io_timing is enabled, otherwise zero)"

pg_process_idle:
  query: |
    WITH
      metrics AS (
        SELECT
          application_name,
          SUM(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - state_change))::bigint)::float AS process_idle_seconds_sum,
          COUNT(*) AS process_idle_seconds_count
        FROM pg_stat_activity
        WHERE state = 'idle'
        GROUP BY application_name
      ),
      buckets AS (
        SELECT
          application_name,
          le,
          SUM(
            CASE WHEN EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - state_change)) <= le
              THEN 1
              ELSE 0
            END
          )::bigint AS bucket
        FROM
          pg_stat_activity,
          UNNEST(ARRAY[1, 2, 5, 15, 30, 60, 90, 120, 300]) AS le
        GROUP BY application_name, le
        ORDER BY application_name, le
      )
    SELECT
      application_name,
      process_idle_seconds_sum as seconds_sum,
      process_idle_seconds_count as seconds_count,
      ARRAY_AGG(le) AS seconds,
      ARRAY_AGG(bucket) AS seconds_bucket
    FROM metrics JOIN buckets USING (application_name)
    GROUP BY 1, 2, 3
  metrics:
    - application_name:
        usage: "LABEL"
        description: "Application Name"
    - seconds:
        usage: "HISTOGRAM"
        description: "Idle time of server processes"
