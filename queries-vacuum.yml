pg_vacuum_dead_rows:
  query: |
    SELECT
      c.oid AS "oid",
      n.nspname AS "schema",
      c.relname AS "table",
      GREATEST(pg_stat_get_dead_tuples(c.oid), pg_stat_get_dead_tuples(t.oid))::int AS "dead_rows"
    FROM pg_class c
    LEFT JOIN pg_class AS t ON c.reltoastrelid = t.oid
    JOIN pg_namespace n on c.relnamespace = n.oid
    WHERE c.relkind IN ('r', 'm')
    AND GREATEST(pg_stat_get_dead_tuples(c.oid), pg_stat_get_dead_tuples(t.oid)) > 0
    AND n.nspname <> 'pg_catalog'
    AND n.nspname <> 'information_schema'
    ORDER BY dead_rows DESC
  master: true
  metrics:
    - dead_rows:
        usage: "COUNTER"
        description: "Number of dead rows"
    - oid:
        usage: "LABEL"
        description: "Some desc"
    - schema:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - table:
        usage: "LABEL"
        description: "Name of the table"

pg_vacuum_disk_usage:
  query: |
    SELECT
      c.oid AS "oid",
      n.nspname AS "schema",
      c.relname AS "table",
      GREATEST(pg_stat_get_dead_tuples(c.oid), pg_stat_get_dead_tuples(t.oid)) AS "dead_rows"
    FROM pg_class c
    LEFT JOIN pg_class AS t ON c.reltoastrelid = t.oid
    JOIN pg_namespace n on c.relnamespace = n.oid
    WHERE c.relkind IN ('r', 'm')
    AND GREATEST(pg_stat_get_dead_tuples(c.oid), pg_stat_get_dead_tuples(t.oid)) > 0
    AND n.nspname <> 'pg_catalog'
    AND n.nspname <> 'information_schema'
    ORDER BY dead_rows DESC
  metrics:
    - schema:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - table:
        usage: "LABEL"
        description: "Name of the table"
    - dead_rows:
        usage: "COUNTER"
        description: "Number of dead rows"

pg_last_vacuum_run:
  query: |
    SELECT
      c.oid AS "oid",
      n.nspname AS "schema",
      c.relname AS "table",
      s.last_vacuum AS last_manual_vacuum,
      now() - s.last_vacuum AS time_since_last_manual_vacuum,
      s.last_autovacuum AS last_auto_vacuum,
      now() - s.last_autovacuum AS time_since_last_auto_vacuum
    FROM pg_class c
    JOIN pg_namespace n ON c.relnamespace = n.oid
    JOIN pg_stat_all_tables s ON c.oid = s.relid AND (s.last_vacuum IS NOT NULL OR s.last_autovacuum IS NOT NULL)
    WHERE c.relkind IN ('r', 'm')
    ORDER BY time_since_last_auto_vacuum DESC
  metrics:
    - schema:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - table:
        usage: "LABEL"
        description: "Name of the table"
    - last_manual_vacuum:
        usage: "GAUGE"
        description: "Last time at which this table was manually vacuumed"
    - last_auto_vacuum:
        usage: "GAUGE"
        description: "Last time at which this table was automatically vacuumed"
    - time_since_last_auto_vacuum:
        usage: "GAUGE"
        description: "Time passed since last automatically vacuum"

        #pg_manual_vacuum_events:
        #  query: |
        #    SELECT
        #      c.oid AS "oid",
        #      n.nspname AS "schema",
        #      c.relname AS "table",
        #      s.vacuum_count AS number_manual_vacuum
        #    FROM pg_class c
        #    JOIN pg_namespace n ON c.relnamespace = n.oid
        #    JOIN pg_stat_all_tables s ON c.oid = s.relid AND (s.vacuum_count > 0)
        #    WHERE c.relkind IN ('r', 'm')
        #    ORDER BY number_manual_vacuum DESC
        #
        #pg_auto_vacuum_events:
        #  query: |
        #    SELECT
        #      c.oid AS "oid",
        #      n.nspname AS "schema",
        #      c.relname AS "table"
        #      s.autovacuum_count AS number_auto_vacuum
        #    FROM pg_class c
        #    JOIN pg_namespace n ON c.relnamespace = n.oid
        #    JOIN pg_stat_all_tables s ON c.oid = s.relid AND (s.autovacuum_count > 0)
        #    WHERE c.relkind IN ('r', 'm')
        #    ORDER BY number_auto_vacuum DESC
        #
        #pg_duration_vacuum_execution:
        #  query: |
        #    SELECT
        #      p.pid,
        #      now() - a.xact_start AS duration, coalesce(wait_event_type ||'.'|| wait_event, 'f') AS waiting,
        #      CASE
        #        WHEN a.query ~*'^autovacuum.*to prevent wraparound' THEN 'wraparound'
        #        WHEN a.query ~*'^vacuum' THEN 'user'
        #        ELSE 'regular'
        #      END AS mode,
        #      p.datname AS database, p.relid::regclass AS table,
        #      p.phase,
        #      pg_size_pretty(p.heap_blks_total * current_setting('block_size')::int) AS table_size,
        #      pg_size_pretty(pg_total_relation_size(relid)) AS total_size,
        #      pg_size_pretty(p.heap_blks_scanned * current_setting('block_size')::int) AS scanned,
        #      pg_size_pretty(p.heap_blks_vacuumed * current_setting('block_size')::int) AS vacuumed,
        #      round(100.0 * p.heap_blks_scanned / p.heap_blks_total, 1) AS scanned_pct,
        #      round(100.0 * p.heap_blks_vacuumed / p.heap_blks_total, 1) AS vacuumed_pct,
        #      p.index_vacuum_count,
        #      round(100.0 * p.num_dead_tuples / p.max_dead_tuples,1) AS dead_pct
        #    FROM pg_stat_progress_vacuum p
        #    JOIN pg_stat_activity a using (pid)
        #    ORDER BY now() - a.xact_start DESC
        #
        #pg_completed_vacuum_index_cycles:
        #  query: |
        #    SELECT
        #      p.pid,
        #      now() - a.xact_start AS duration, coalesce(wait_event_type ||'.'|| wait_event, 'f') AS waiting,
        #      CASE
        #        WHEN a.query ~*'^autovacuum.*to prevent wraparound' THEN 'wraparound'
        #        WHEN a.query ~*'^vacuum' THEN 'user'
        #        ELSE 'regular'
        #      END AS mode,
        #      p.datname AS database, p.relid::regclass AS table,
        #      p.phase,
        #      pg_size_pretty(p.heap_blks_total * current_setting('block_size')::int) AS table_size,
        #      pg_size_pretty(pg_total_relation_size(relid)) AS total_size,
        #      pg_size_pretty(p.heap_blks_scanned * current_setting('block_size')::int) AS scanned,
        #      pg_size_pretty(p.heap_blks_vacuumed * current_setting('block_size')::int) AS vacuumed,
        #      round(100.0 * p.heap_blks_scanned / p.heap_blks_total, 1) AS scanned_pct,
        #      round(100.0 * p.heap_blks_vacuumed / p.heap_blks_total, 1) AS vacuumed_pct,
        #      p.index_vacuum_count,
        #      round(100.0 * p.num_dead_tuples / p.max_dead_tuples,1) AS dead_pct
        #    FROM pg_stat_progress_vacuum p
        #    JOIN pg_stat_activity a using (pid)
        #    ORDER BY now() - a.xact_start DESC
        #
        #pg_number_of_rows_modified:
        #  query: |
        #    SELECT
        #      c.oid AS "oid",
        #      n.nspname AS "schema",
        #      c.relname AS "table",
        #      GREATEST(pg_stat_get_mod_since_analyze(c.oid), pg_stat_get_mod_since_analyze(t.oid)) AS "dead_rows"
        #    FROM pg_class c
        #    LEFT JOIN pg_class AS t ON c.reltoastrelid = t.oid
        #    JOIN pg_namespace n on c.relnamespace = n.oid
        #    WHERE c.relkind IN ('r', 'm')
        #    AND GREATEST(pg_stat_get_mod_since_analyze(c.oid), pg_stat_get_mod_since_analyze(t.oid)) > 0
        #    ORDER BY dead_rows DESC
        #
